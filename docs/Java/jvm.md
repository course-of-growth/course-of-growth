## 一.Java代码是如何运行的
### 为什么Java要在虚拟机中运行
参考：[
jvmbytes](http://jvmbytes.com/#/learning-java/jvm/java-jvm-arch)
- Java作为有一门高级语言，其语法比较复杂，抽象度高，所以直接运行在硬件上并不现实，通过设计一个面向Java语言的虚拟机，通过编译器将Java程序转换成字节码，生成的字节码文件可以运行在各种平台上，这也就体现了Java跨平台的特性。
- 虚拟机的另一个好的出就是托管环境，Java虚拟机能够自动进行内存管理和垃圾回收。
- Java虚拟机还提供了注入数组索引越界、动态类型、安全权限等动态监测，开发者只需将重点放在业务开发。

### Java字节码是怎么运行的
以HotSpot虚拟机为例：
- 首先虚拟机将编译生成的字节码文件加载，存放于`方法区（Method Area）`,在实际运行过程中，虚拟机会执行方法区中的代码。
- Java虚拟机会将栈细分为面向Java 方法的Java 方法栈，面向本地方法的本地方法栈，以及存放各个线程执行位置的PC寄存器。
- 在运行过程中，每当调用一个Java方法，Java虚拟机就会在当前线程的Java方法栈中生成一个`栈帧`，用来存放`局部变量`以及`字节码的操作数`。每个栈帧的大小是提前计算好的，而且Java虚拟机不要求栈帧在内存中连续分布。
- 在退出当前执行的方法时，不论此方法是正常返回还是发生异常，Java虚拟机都会弹出当前线程的当前栈帧，并将之舍弃。

### Java是一种编译型语言还是解释型语言？

参考：[知乎：Java 是编译型语言还是解释型语言？](https://www.zhihu.com/question/19608553)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527002646554.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbGxpbkM=,size_16,color_FFFFFF,t_70)

从硬件角度来看，Java字节码文件是无法直接运行在机器上的，需要将字节码文件转换为机器码。
在HotSpot里面，将Java字节码文件转换为机器码有两种实现方式：
- `解释执行（interpreter）`：逐条将字节码文件翻译成机器码，即将程序计数器中指向的待执行的java字节码翻译为cpu可以运行的机器指令。这种方式的优势就是无需等待编译。
- `即时编译（JIT）`：将一个方法中包含的所有字节码编译成机器码然后执行，其优势就是实际运行速度更快。

 HotSpot默认采用混合方式，先解释执行字节码，然后将那些反复出现的热点代码以方法为单位进行即时编译。

### Java虚拟机是如何提高运行效率
HotSpot采用了很多的技术来提升启动性能以及峰值性能，上面所提到的即时编译就是其中一种重要的技术

即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。

**对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，采用解释执行的方式运行；另一方面，对于一小部分的热点代码，则可以将其编译成为机器码，以提高运行速度。**

为满足不同场景，HotSpot内置了多个即时编译器：
- `C1`:又称为Client编译器，主要适用于对启动性能有要求的客户端GUI程序，采用的优化手段相对简单，因此编译时间较短
- `C2`：有称为Servcer编译器，适用于对峰值性能有要求的服务端程序，采用的优化手段较为复杂，因此其编译时间较长，同时生成代码的执行效率较高。
- `Graal`:Java10引入，与interpreter、GC等JVM的其他一些子系统相比较，JIT compiler并不依赖与诸如直接使用内存访问的底层语言特性。可以把它看成是一个输入Java bytecode 输出二进制码的黑盒，其实现方式取决于开发者对开发效率，可维护性的要求。Graal是一个Java作为主要编程语言，面向Java bytecode的编译器。与C++实现的C1与C2相比，它的模块化更加明显，也更加容易维护。Graal既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现AOT编译（ahead of time conpilation）在线下将bytecode 编译成机器码以解决启动性能不好的问题。

参考：[Java10来了，来看看它一同发布的全新JIT编译器
](https://mp.weixin.qq.com/s?__biz=MzIzNjI1ODc2OA==&mid=2650887163&idx=1&sn=12c7182e42659e4c5bcb0b8c61442e3d&chksm=f32f6744c458ee52783af6d315db377acf7587de1cf13f7bf3b76e2dfe7d2fffddad53c5958f&mpshare=1&scene=23&srcid=&sharer_sharetime=1591027260610&sharer_shareid=caee56c3dcf3edfff43d8bc355b0e54d#rd)

之所以有这么多的即时编译器，就是为了在编译时间和生成代码的执行效率之间进行取舍。

从Java7开始，HotSpot默认采用分层编译的方式：即热点方法首先会被C1编译，然后热点方法中热点会进一步被C2编译。

为了不干扰应用的正常运行，HotSpot的即时编译是放在额外的编译线程中进行。HotSpot会根据CPU的数量设置编译线程的数目，并且按照1:2的比例配置给C1及C2编译器。

计算资源充足的情况下，字节码的解释执行和编译执行是可以同时进行的。编译完成的机器码会在下次替换那个该方法的时候启用，替换原来的解释执行。

## 二.Java类加载过程
  从 class 文件到内存中的类，要经过`加载`、`链接`以及`初始化`三大步骤
### 是不是所有的Java类都需要三大步骤
  Java语言的类型可以分为两大类：基本类型和引用类型。

基本类型是由Java虚拟机预先定义好的；

而对于引用类型，Java将其细分为四类：类、接口、数组类和泛型参数。由于泛型参数会在编译过程中被擦除，因此Java虚拟机中实际上游前三种。

在类、接口和数组类中，数组类是由Java虚拟机直接生成的，其他两种则有对应的字节流。

对于字节流，最常见的形式就属由Java编译器生成的class文件。除此之外，我们也可以在程序内部直接生成，或者从网络中获取（例如网页中内嵌的小程序 Java applet）。这些不同形式的字节流，会被加载到Java虚拟机中，称为类或者接口。

无论是生成的数组类，还是加载的类，Java虚拟机都需要对其进行链接和初始化。

### 加载
加载，是指查找字节流并且创建类的过程。除了数组类以外，其他的类都需要借助类加载器来完成查找字节流的过程。

**类加载器：**

参考：[知乎：通俗易懂 启动类加载器、扩展类加载器、应用类加载器](https://zhuanlan.zhihu.com/p/73359363)

类加载器的作用，就是将class文件装进虚拟机，宏观来看，只有两种类加载器：`启动类加载器`和`其他类加载器`。
- 启动类加载器（Bootstrap ClassLoader）：由C++实现，没有对应的Java对象，因此在Java中只能用null来指代。
- 其他类加载器：都是`java.lang.ClassLoader`的子类，因此有对应的Java对象。这些类加载需要先由另一个类加载，比如启动类加载器，加载至Java虚拟机中，方能执行类加载。

既然只是讲class文件装入虚拟机，为什么要用这么多种类加载器？因为在Java虚拟机启动时，并不会一次性加载所有的class文件（内存会爆），而是根据需求去动态的加载。

在Java9 之前，启动类加载器负责最为基础的、最为重要的类，比如存放在 JRE 的lib目录下的jar包下的类（以及由虚拟机参数 -Xbootclasspath 指定的类）。除了启动类加载器之外，另外两个重要的类加载器是`拓展类加载器`（extension class loader）和`应用类加载器`（application class loader），均由Java核心类库提供。

拓展类加载器的父类是启动类加载器。它负责加载相对次要的、但是又通用的类，比如存放在 JRE 的lib/ext 目录下jar包中的类（以及由系统变量java.ext.dirs指定的类）

应用加载器的父类则是拓展类加载器，负责记载应用程序路径下的类。（这里的应用程序路径，指的是虚拟机参数 -cp/-classpath、系统变量java.calss.path或环境变量CLASSPATH所制指定的路径。）默认情况下，应用程序中所包含的类便是由应用类记载器加载的。

Java9 引入了模块系统，并且将拓展类加载器改名为`平台类加载器`（platform class loader）。Java SE中 除了少数的几个关键的模块，比如java.base是由启动类加载器加载之外，其他的模块均是由平台类加载器所加载。

除了由Java 核心类库提供的类加载器之外，我们还可以加入自定义类加载器，来实现特殊的加载方式。举例来说，我们可以对class文件进行加密，加载时再利用自定的类加载器对其进行解密。

除了加载功能之外，类加载器还提供了命名空间的作用。

在Java虚拟机中，类的唯一性是由类加载器的实例和类的全名一同决定的，即使是由同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一类的不同的版本。


**双亲委派模型：**

在Java虚拟机中，每当一个类加载器接收到加载请求时，它会先将请求转发给父类加载器。在父类加载器没有找到所请求的情况下，该类加载器才会尝试去加载。

### 链接
链接是指将创建成的类合并至Java虚拟机中，使之能够执行的过程。它可分为`验证` 、`准备`以及`解析`三个阶段。
- 1.验证：确保被加载的类能够满足Java虚拟机的约束条件。通常而言，Java编译器生成的类文件必须满足Java虚拟机的约束条件。
- 2.准备：为被加载的类的静态变量分配内存。部分Java虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如用来实现需方法的动态绑定的方法表。
在class文件被记载至Java虚拟机之前，这个类无法知道其他类及其方法、字段所引用的具体地址，甚至不知道自己的方法、字段的地址。因此，每当需要引用这些成员时，Java编译器会生成一个符号引用。在运行阶段，这个符号引用一般都能够无歧义地定位到具体的目标上。
举例来说，对于一个方法的调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接受参数类型以及返回值类型的符号引用，来指代所要调用的方法。
- 3.解析：这个阶段的目的，正是将这些符号引用解析成实际引用。如果符号引用指向一个未被加载的类，或者未被加载的类的字段和方法，那么解析将会触发这个类的加载（但是未必会触发这个类的链接以及初始化）

>Java虚拟机规范并没与要求在来链接过程中完成解析。它仅规定了：`如果某些字节码使用了符号引用，那么在执行这些字节码之前，需要完成对这些符号引用的解析。`

### 初始化
在Java代码中，如果要初始化一个静态字段，我么可以在声明时直接赋值们也可以在静态代码块中对其赋值。
  
如果直接赋值的静态字段被final修饰，并且它的类型是基本数据类型或者字符串时，那么该字段便会被Java编译器标记成常量值（ConstantValue）,其初始化直接由Java虚拟机完成。除此之外的直接赋值操作，以及所有静态代码块中的代码，则会被Java编译器置于同一方法中，并把它命名为`<clinit>`

类加载的最后一步是初始化，便是为标记为常量值得字段赋值，以及执行 `<clinit>`方法的过程。Java虚拟机会通过加锁来确保类的`<clinit>`方法仅被执行一次。

只有当初始化完成之后，类才真正成为可执行的状态。

那么类的初始化合适才会被触发呢？JVM规范枚举了下面几种触发情况：
- 当虚拟机启动时，初始化用户指定的主类
- 当遇到用以新建目标类实例的new指令是，初始化new指令的目标类
- 当遇到调用静态方法的指令时，初始化该静态方法所在的类
- 当遇到访问静态字段的指令时，初始化该静态字段所在的类
- 子类的初始化会触发父类的初始化
- 如果一个接口定义了default 方法，那么直接实现或间接实现该接口的类的初始化，会触发该接口的初始化
- 使用反射API对某一个类进行反射调用时，初始化这个类
- 当初次调用MethodHandle 实例时，初始化该MethodHandle指向的方法所在的类。

## 三.JVM执行方法调用过程
### 重载和重写

在Java程序中，如果同一个类中出现多个名字相同，并且参数类型相同的方法，那么它无法通过编译。而在正常情况下，如果想要在一个类中定义同名方法，那么其参数类型必须不同。这些方法之间的关系，就是`重载`。

重载的方法在编译过程中即可完成识别。具体到每一个方法的调用，Java 编译器会根据所传入的参数声明类型（注意与实际类型的区别）来选取重载方法。选取的过程分为三个阶段：

- 1.在不考虑对基本类型自动拆装箱，以及可变长参数的情况下选取重载方法。
- 2.如果在第一个阶段没有找到适配的方法，那么在允许自动产装箱，不允许可变长参数的情况下选取重载方法。
- 3.如果在第二个阶段没找到适配的方法，那么在允许自动拆装箱以及可变长参数的情况下选取重载方法。

`如果Java编译器在同一个阶段找了多个适配的方法，那么它会在其中选择一个最为贴切的，而决定贴切程度的一个关键就是形式参数类型的继承关系。`

```java 
void invoke(Object obj, Object... args) { ... }
void invoke(String s, Object obj, Object... args) { ... }
 
invoke(null, 1);    // 调用第二个 invoke 方法
invoke(null, 1, 2); // 调用第二个 invoke 方法
invoke(null, new Object[]{1}); // 只有手动绕开可变长参数的语法糖，
                               // 才能调用第一个 invoke 方法
```

上面这串代码，假设想调用第一个方法，传入的参数为（null，1）。也就是说，声明为Object的形式参数所对应的实际参数为null,而变成参数则对应1。

通常来说，之所以不提倡可变长参数方法的重载，是因为Java编译器可能无法决定应该调用哪个目标方法。

在这种情况下，编译器会报错，并且提示这个方法调用有二义性。然而，Java编译器直接将方法调用识别为调用第二个方法。

当传入null是，它既可以匹配第一个方法中什么行为Object的形式参数，也可以匹配第二个方法中申明为String的形式参数。`由于String是Object的子类，因此Java编译器认为第二个方法更为贴切。`

除了同一个类中的方法，重载也可以作用于这个类所继承而来的方法。也就是说，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。

那么，如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？

`如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。如果这两个方法都不是静态的，且都不是私有的，那么子类重写了父类的方法。`

众所周知，Java是一门面向对象的编程语言，它一个重要的特性就是多态。而方法的重写，正是多态的一种重要的体现；它允许子类在继承父类部分功能的同时，拥有自己独特的行为。

重写会根据调用者的动态类型，来选取实际的目标方法。

### JVM的静态绑定和动态绑定

Java虚拟机识别方法的关键在于类名、方法名和方法描述符（method descriptor）。

方法描述符，它是由方法的参数类型以及返回类型所构成的。在一个类中，如果同时出现多个名字相同并且描述的符相同的方法，那么Java虚拟机会在类验证的阶段报错。

可以看出，Java虚拟机和Java语言不同，它不限制名字和参数类型相同，并且参数类型不同的方法出现在同一个类中，




