## Docker 与 容器化技术

微服务架构本质是一个分布式系统，分布式系统早于微服务架构之前就已经出现了。分布式系统的复杂性除了体现在开发时，对运维也提出了更高的要求，需要部署的应用数量从一个变成了几个甚至几十个。如果在运维方面没有相应的技术提升，微服务架构也不可能得到广泛的应用。

容器化技术的出现，为系统运维带来了新的可能性，微服务架构应用的部署离不开容器化技术。

下图为应用部署的发展阶段，从传统部署到硬件虚拟化，再到容器化。

![image](https://dyzzz.oss-cn-beijing.aliyuncs.com/img/docker01.png)

### 1.硬件虚拟化技术

在早期的时候，应用都是直接被安装在操作系统中的。在进行扩展时，我们需要在新的物理机器上安装操作系统，再安装应用，这种方式的问题在于**当多个应用共享物理资源时，一个应用可能占用过多的资源，从而影响其他应用的性能**。另外，这种方式进行**扩展的速度也很慢，需要从物理机器开始，无法快速响应业务的需求**。

硬件虚拟化技术的出现，为拓展提供了新的解决方案，硬件虚拟化指的是`对计算机虚拟化，虚拟化对用户隐藏了计算平台的物理特性，仅提供了一个抽象的计算平台`。

用来控制虚拟化的程序称为 Hypervisor，它可以创建和运行虚拟机。在虚拟机上我们可以安装不同类型的操作系统，包括 Windows、Linux 和 MacOS，虚拟机实例共享虚拟化的硬件资源。Hypervisor 通常分成两类：第一类 Hypervisor 直接在硬件上运行，如 Xen 和微软的 Hyper-V；第二类 Hypervisor 运行在已有的操作系统上，如 VMware Workstation、VMware Player、VirtualBox 和 QEMU。

硬件虚拟化使得我们可以更加充分地利用硬件资源，在创建集群时，可以用少数大型服务器替换掉数量较多的小型服务器。在这些服务器上运行 Hypervisor，并根据需要创建和运行虚拟机；在虚拟机上运行操作系统，而在操作系统上运行应用。

在创建虚拟机时我们可以限制虚拟机的 CPU、内存和硬盘等资源，硬件虚拟化可以更好的支持扩展。Hypervisor 可以从镜像文件中快速创建出虚拟机实例，当需要增加应用实例时，我们可以从保存的镜像中创建虚拟机并运行。**处理应用的失败也变得简单，只需要创建新的虚拟机实例替换掉出错的即可**。

### 2.容器化技术

硬件虚拟化的不足之处在于只能以操作系统为单位来进行扩展，操作系统本身也需要占用资源。当虚拟机的数量增加时，很多资源都被虚拟机中的操作系统占用。操作系统级别的虚拟化，也就是容器化，可以在隔离的容器中运行程序。容器中运行的程序只能访问操作系统的部分资源，包括CPU、内存、文件系统和网络等。目前最为流行的容器化实现是Docker，除此之外，还有 LXC 和 Container Linux 等实现。

容器是一个不依赖于操作系统，运行应用程序的环境。它通过Linux 的 Namespace 和 Cgroups 技术对应用程序进行隔离和限制的， Namespace 的作用是`隔离`，它让应用进程只能看到该NameSpace内的世界；而Cgroups的作用是`限制`分配给进程的宿主机资源。但对于度主机来说，这些被隔离了的进程和其他进程并没有太大区别。

`容器是怎么工作的`：

Namespace的作用是隔离，它让应用进程只能看到该Namespace内的世界；而Cgroups的作用是限制，它给这个世界围上了一圈看不见的墙。通过Mount Namespace可以修改容器进程对自己的文件系统 "挂载点"的认知。在容器进程启动之前重新挂载它的整个根目录"/"（通过pivot_root系统调用改变进程的文件系统，如果系统不支持，则使用chroot），而由于Mount Namespace的存在，这个挂载对宿主机不可见的。这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫做：rootfs（根文件系统）。rootfs只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。

所以说，rootfs 只包括了操作系统的 "躯壳"，并没有包括操作系统的内核。同一台机器上的所有容器，都会共享宿主机操作系统的内核。
这就意味着，如果容器里的应用程序需要配置内核参数、跟内核进行直接的交互，这些都是操作的宿主机操作系统的内核，它对于该机器上的所有容器来说是一个“全局变量”，牵一发而动全身。这也是容器相比于虚拟机的主要缺陷之一：毕竟虚拟机有模拟出来的硬件机器充当沙盒，而且每个虚拟机里还运行着一个完整Guest OS让应用随便折腾。不过由于rootfs里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。这就赋予了容器所谓的一致性：无论在本地、云端，还是在一台任何地方的机器上，用户只需要解压打包好的容器镜像，那么这个应用运行所需要的完整的执行环境就能被重现出来。

![image](https://dyzzz.oss-cn-beijing.aliyuncs.com/img/docker04.png)

随着Docker 的流行，容器化的实现也得到了广泛的应用。相对于基于 Hypervisor 的硬件虚拟化， 容器化有许多优势。

**传统部署流程的问题**

在早期的软件开发实践中，开发和运维团队的职责划分并不清晰。开发团队的成员在自己的本地环境上开发，通过持续集成环境构建出可部署的工件（Artifact），部署的工作由运维团队来完成。根据开发团队提供的文档，**在生产环境上安装应用及其依赖的外部服务，比如数据库和消息中间件等。**

这样的开发部署流程最大的问题在于，`无法保证开发时和运行时环境的一致性`。经常出现的问题是，应用在开发人员的开发环境上可以正常工作，到了生产环境中则会出现各种问题。有可能开发人员在本地环境上为应用添加了一个新的参数，但是忘了更新安装文档，导致运维团队安装的生产环境应用出现问题。

下图是传统的部署方式，可以看出，最大的问题在于手动维护安装文档，任何手动维护的文档从根本上来说都是不可信的，文档可能与代码失去同步。

![image](https://dyzzz.oss-cn-beijing.aliyuncs.com/img/docker02.png)

开发和生产环境的这种不一致性，会随着应用的复杂性而加剧。从单体应用迁移到微服务架构，对应用部署的要求更高，需要部署的应用数量从一个变成多个，而且每个服务所使用的技术栈和依赖的外部服务都可能千差万别。如果以硬件虚拟化来实现，还需要为`每个服务创建独立的操作系统镜像，这些镜像的管理、更新和维护`都是一个巨大的挑战。

- `容器的优势`:

容器占用的大小比虚拟机小很多，甚至可以小到10M，可以轻松限制容器的内存和CPU使用率。与部署应用需要部署整个操作系统的虚拟机来说，容器非常轻巧且启动迅速。这样我们可以快速地扩容容器并添加相同的容器。

同样，容器也是持续集成和持续部署的实施极好的选择，它们通过在开发人员之间分发和合并镜像来促进协作开发。

容器化技术提供了一种更简洁的方式来描述可运行的应用，可运行对运维来说至关重要。以 Java 应用为例，开发人员在本地环境上进行开发和调试，通过持续集成构建出可部署的 JAR 文件。但对运维团队来说，这些 JAR 文件并不是可运行的，因为它们还缺少所依赖的运行时支持，最基本的运行时依赖是 JDK，Java 应用对依赖的 JDK 版本是有要求的，除此之外，Java 应用启动时还可能需要额外的参数，这些信息并不包含在 JAR 文件中。因此运维团队需要从开发团队中获取这些信息，开发团队通常使用文档来说明如何运行应用，而文档本身很容易与代码产生不一致。

使用容器化技术所创建的镜像包含了应用所依赖的全部内容。一个 Java 应用的镜像，除了包含应用本身的 JAR 文件之外，还包含所需的 JDK 和如何启动应用的信息。`容器的镜像是自包含的，同时也是可运行的`。运维团队所做的仅仅是从镜像中创建容器并运行。这就进一步明确开发和运维团队的职责，开发团队负责创建应用对应的镜像，而运维团队只负责管理基础设施和容器的运行。

如下图所示，在容器化的部署方式中，应用镜像是开发团队和运维团队的唯一交集。

![image](https://dyzzz.oss-cn-beijing.aliyuncs.com/img/docker05.png)

`容器镜像的最大优势是不可变`，不可变性在运维中的作用巨大，这一点和虚拟机镜像类似，但是容器镜像更加轻量级。在进行版本更新时，如果出现未预期的问题，只需要用上一个版本的镜像重新运行容器，就可以快速回退。当在生产环境中发现问题时，开发人员可以在本地环境上运行同样版本的镜像来重现问题。

容器化解决了不同环境之间的一致性问题，开发团队产出的应用镜像，经过测试团队的测试之后，被部署到生产环境中。开发、测试和生产环境使用的是同样的不可变镜像，这样的一致性对于应用的更新至关重要。

虽然容器对所运行的进程数量没有限制，`但是一般容器只运行一个进程`。为了运行应用，除了应用本身的容器之外，`应用所需的其他服务也运行在各自的容器中`，这就要求协调不同容器的运行。容器编排工具的作用就是解决这个问题，常见的容器编排工具包括 `Kubernetes`、Docker Swarm 和 Apache Mesos。

- `容器的劣势`:

容器仍无法提供与虚拟机相同的安全性和稳定性。由于它们共享主机的内核，因此不能像虚拟机一样完全隔离。

容器是进程级的隔离，一个容器可以通过影响宿主机内核的稳定性来影响其他容器。

一旦容器执行了任务，它就会关闭并删除其中的所有数据。如果希望数据保留下来，则必须使用数据卷进行操作，这需要在主机上进行手动配置。

### Docker 的使用

在众多容器化技术中，Docker 是最流行的一个，采用`客户端 — 服务器`的架构。服务器端是 Docker 后台程序，负责构建、运行和分发容器；客户端则通过 REST API 与 Docker 后台程序交互。

Docker中两个最重要的概念就是镜像和容器，`镜像是创建容器的只读模板`，可以从Docker注册表中下载，也可以创建自定义镜像。Docker Hub 是默认的镜像注册表，包含了许多可用的镜像，企业内部也可以搭建自己私有的注册表。镜像虽然是不可变的，但是可以在已有的镜像上进行定制，得到新的镜像，这也是通常创建镜像的方式。`容器是镜像的可运行实例，从镜像中创建出来的容器`，可以被启动、暂停、停止和删除。

**安装**

Docker 的安装很简单。在本地开发环境中，Windows 和 MacOS 可以安装 Docker Desktop，对于 Docker Desktop 不支持的 Windows 版本，可以安装 Docker Toolbox；在 Linux 上则需要安装 **Docker Engine**。

- 1.安装环境

>此处在Centos7 进行安装，可以用以下命令查看Centos 版本
```
rpm -q centos-release
```
![image](https://dyzzz.oss-cn-beijing.aliyuncs.com/img/docker06.png)
>在 CentOS 7安装docker要求系统为64位、系统内核版本为 3.10 以上，可以使用以下命令查看
```
uname -r
```
![image](https://dyzzz.oss-cn-beijing.aliyuncs.com/img/docker07.png)

- 2.yum 源安装 docker

>查看是否已经安装docker
```
yum list installed | grep docker
```

>安装docker
```
yunm -y install docker
```

注：-y 表示不询问安装，直到安装成功

>启动docker
```
systemctl start docker
```

>查看 docker 服务
```
systemctl status docker
```


