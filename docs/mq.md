## 一.消息队列解决了哪些问题
通俗来说，消息队列的主要功能就是收发消息，但是它的作用不仅仅只是解决应用之间的通信问题这么简单。

日常开发中哪些问题适合使用消息队列来解决呢？

### 1.异步处理

就以前段时间面试最火的问题————如何设计一个秒杀系统举例。`秒杀系统需要解决的核心问题就是如何利用好有限的服务器资源，尽可能多地处理短时间内的海量的数据请求`。

一般秒杀请求包含以下几个步骤：
- 风险控制
- 库存锁定
- 生成订单
- 短信通知
- 更新统计数据

如果没有任何的优化的话，正常的处理流程就是：APP将请求发送给网关了，依次调用以上5个流程，然后将结果返回给APP.
对于这五个步骤来说，能否决定秒杀成功，实际上只有风险控制和库存锁定这两个步骤。只要用户的秒杀请求完成这两个步骤，对于后续的步骤，并不一定要在秒杀请求中处理完成，而是可以`将请求的数据放入消息队列中，有消息队列异步地进行后续的操作`，可以充分利用有限的服务资源处理更多真正的秒杀请求。

![Image text](https://dyzzz.oss-cn-beijing.aliyuncs.com/img/miaosha.png)

优点：
- 更快地返回结果
- 减少等待，自然实现了步骤之间的并发，提升了系统总体的性能

### 2.流量控制
一个设计健壮的程序有自我保护能力，也就是说，它能够在海量的请求下，还能在自身能力范围内尽可能多地处理请求，拒绝处理不了请求并且保证自身正常运行。但是大多的程序并没有那么“健壮”，而直接拒绝请求返回错误对于用户来说体验也不好。

因此，需要设计一套健壮的架构来将后端的服务保护起来。一般的设计思路是： `使用消息队列隔离网关和后端服务，以达到流量控制和保护后端服务的目的`。

加入消息队列后，整个秒杀流程变为：
- 1.网关在收到请求后，将请求放入消息队列中
- 2.后端服务从请求消息队列中获取APP请求，完成后续秒杀处理过程，然后返回结果。
![Image text](https://dyzzz.oss-cn-beijing.aliyuncs.com/img/mq1.png)

秒杀开始后，当短时间内的大量秒杀请求到达网关后，不会直接冲击到后端的秒杀服务，而是先堆积在消息队列中，后端服务按照自己的最大处理能力，从消息队列中消费请求进行处理。

对于`超时`的请求可以直接丢弃，APP将超时无响应的请求处理为秒杀失败即可。运维人员还可以随时增加秒杀服务的实例数量进行水平扩容，而不用对系统的其他部分做任何的修改。

这样设计的优点就是：`能根据下游的处理能力自行调节流量，达到“削峰填谷”的作用`。

但是同样这种设计也有缺点：
- 增加了系统的调用链，导致总体的响应时间变长
- 上下游系统都要将同步调用调整为异步消息，增加了系统的复杂度。


除了上面的那种方式以外，还有相对简单的流量控制方法：如果可以预估出秒杀服务的处理能力，就可以用消息队列实现一个令牌桶，更加简单地进行流量控制。

令牌桶控制流量的原理就是：单位时间内只发放固定数量的令牌到令牌桶中，规定服务在处理请求之前必须从令牌桶中拿出一个令牌，如果令牌桶中没有令牌，则拒绝请求。这样就可以保证单位时间内请求的数量不会超过发放令牌的数量，起到了流量控制的作用。

![Image text](https://dyzzz.oss-cn-beijing.aliyuncs.com/img/mq2.png)

其实现方式也很简单，不需要破坏原有的调用链，只要网关在处理APP请求时增加一个获取令牌的逻辑

令牌桶可以简单地用一个有固有容量的消息队列加一个“令牌发生器”来实现；令牌发生器按照预估的处理能力，均速生成令牌并放入令牌队列（如果队列满了则丢弃令牌），网关在收到请求时去令牌对列消费一个令牌。获取到令牌，获取到立牌则继续调用后端秒杀服务，如果获取不到令牌则直接返回秒杀失败。

### 3.服务解耦
消息队列还可以实现系统应用之间的解耦。

就以常见的电商项目为例，订单系统是比较核心的系统，当一个新的订单创建的时候
- 1.支付系统需要发起支付流程
- 2.风控系统需要审核订单的合法性
- 3.客服系统需要短息通知用户
- 4.运营分析系统需要更新数据
...

这些订单下游的系统都需要实时获得订单数据。随着业务不断发展，这些订单下游系统不断的增加，不断变化，并且每个系统可能只需要订单数据的一个子集，负责订单服务的开发团队不得不花费很大的精力，应对不断增加变化的下游系统，不停地修改调试订单系统与这些下游系统的接口。任何一个下游系统接口变更，都需要订单模块重新进行一次上线，对于一个电商的核心服务来说，这几乎是不可接受的。

所有的电商都选择用消息队列来解决类似的系统耦合过于紧密的问题。引入消息队列后，订单服务在订单变化时发送一条消息到消息队列的一个主题 Order 中，所有下游系统都订阅主题 Order，这样每个下游系统都可以获得一份实时完整的订单数据。

无论增加、减少下游系统或是下游系统需求如何变化，订单服务都无需做任何更改，实现了订单服务与下游服务的解耦。

### 其他
除了上面的三种最为常见的使用场景，还包括：
- 作为发布/订阅系统实现一个微服务级系统间的观察者模式；
- 连接流计算任务和数据
- 用于将消息广播给大量的接受者

简单的来说，我们在单体应用里面需要用到消息队列解决的问题，在分布式系统中大多数都可以用消息队列来解决

消息队列也有其自身的一些问题和局限性：
- 引入消息队列带来的延迟问题
- 增加了系统的复杂度
- 可能会出现数据一致性问题

## 二.如何选择消息队列
常见的消息队列中间件有很多，每一种产品都有自己的优缺点，所以就需要根据现有系统的情况，选择最合适的产品。
一个合格的消息队列中间件，必须具备一下几个特性：
- 消息可靠传递：确保不丢失消息；
- Cluster:支持集群，确保不会因为某个节点宕机导致服务不可用，本质上也是要保证消息不丢失；
- 性能：具备良好的性能，能够满足绝大多数场景下的性能要求。

### 常见的几种消息队列
- `RabbitMQ`

Erlang语言编写，是少数几个支持AMQP协议的消息队列之一。

Rabbit的宣传口号是：Messaging that just works ,"开箱即用的消息队列"。也就是说，`RabbitMQ是一个相当轻量级的消息队列，非常容易部署及使用`。

RabbitMQ 还有一个比较有特色的的功能就是支持非常灵活的路由配置，和其他消息队列不同的是，它在生产者（Producer）和队列（Queue）之间增加了一个Exchange模块，可以将其理解为交换机。

Exchange模块的作用和交换机也非常相似，根据配置的路由规则将生产者发出的消息分到不同的队列中。路由的规则也非常灵活，甚至可以自定义路由规则。

RabbitMQ客户端支持的编程语言大概是所有消息队列中最多的。

缺点：

**RabbitMQ对消息堆积的支持并不好，在它的设计理念中，消息队列是一个管道，大量的消息堆积是一种不正常的情况， 应当尽量的去避免。当大量的消息堆积时，会导致RabbitMQ的性能急剧下降。**

**RabbitMQ的性能相较于其他消息队列是最差的，大概每秒可以处理几万到几十万条消息，其实这个性能已经足够支撑绝大多数的应用场景了，但是，如果应用对消息队列的性能要求非常高的话，那就不要选择RabbitMQ。**

**RabbitMQ使用Erlang语言编写的，该语言难度较大，所以基于其做一些拓展或者二次开发，得慎重考虑维护问题。**


- `RocketMQ`

RocketMQ是阿里开源的消息队列产品，之后建赠与Apache软件基金会，有着不错的性能，稳定性和可靠性，具备一个现代消息队列应该有的几乎所有的功能和特性，并且他还在持续的成长中。

Rocket有非常活跃的中文社区，大多数的问题可以直接找到中文答案。此外，RocketMQ使用Java语言开发的，可以更容易对其进行二次开发或拓展。

RocketMQ对在线业务的响应延时做了很多的优化，大多数情况下都可以做到毫秒级的响应。如果应用场景很`在意响应延时`的话，就应该选择RocketMQ。

RocketMQ的性能比RabbitMQ要高出一个数量级，每秒钟大概可以处理几十万条消息。

RocketMQ的一个劣势就是作为国产的消息队列，相比于国外比较流行的同类产品，在国际上没那么流行，与周边生态系统的集成和兼容程度就要略逊一些了。

- `Kafka`

Kafka最早是由Linkedln开发，目前也是Apache的顶级项目，其最初设计目的在于处理海量的日志。

在早期Kafka为了获得极致的性能，在设计方面做出了很大的牺牲，比如不能保证消息的可靠性，可能会丢失消息，也不支持集群，功能上也比较简陋，这些牺牲对于处理海量日志这个特定的应用场景还是可以接受的。这个时期的Kafka甚至不能称为一个合格的消息队列。

但是，随着这几年Kafka的发展，当下Kafka已经是一个非常成熟的消息队列产品，无论在数据可靠性、稳定性和功能特性方面都可以满足绝大多数的场景需求。

kafka与周边生态系统的兼容性是最好的没有之一，尤其是在大数据和流计算领域，几乎所有的开源软件系统都会优先支持Kafka.

Kafka使用Scala和Java语言开发，设计上使用了批量和异步的思想，这种设计使得Kafka能够做到超高的性能。Kafka的性能，尤其是异步收发的性能，是三者中最好的，但是与RocketMQ并没有量级上的差异，大于每秒钟处理几十万条消息。

但是Kafka这种异步批量设计带来的问题可就是其`同步收发消息的响应延时较高`，因为当客户端发送一条消息的时候，Kafka并不会立即发送出去，而是`要等一会儿攒一批再发送`。所以当业务场景中每秒消息数量没有那么多时，Kafaka的时延反而会比较高。所以Kafka不太适合在线业务场景。

### 其他消息队列
ActiveMQ,老牌消息队列，与现代消息队列存在明显的差距,目前存在的意义就是兼容一些古老的系统。

ZeroMQ,严格来说它是一个基于消息队列的多线程网络库，如果需要消息队列的功能集成到系统进程中，可以考虑使用ZeroMQ。

Pulsar,新兴的开源消息队列产品，最早由Yahoo开发，目前处于成长期，流行度和成熟度相对没有那么高。与其他消息队列不同的是，Pulsar采用存储和计算分离的设计。

### 消息队列使用场景总结

系统对消息队列的功能和性能没有很高的要求，只需要一个开箱即用易于维护的产品，可以使用RabbitMQ。

系统使用消息队列的场景主要是处理在线业务，比如交易系统中用消息队列传递订单，可以使用RocketMQ，因为其低延迟和金融级的稳定性。

系统需要处理海量的消息，比如手机日志、监控信息或者前端的埋点这类数据，或是应用场景大量使用了大数据、流计算相关的开源产品，kafka是最适合的消息队列。

## 三.消息模型
每一款消息队列都有自己的一套消息模型，比如说队列（Queue）、主题（Topic）或者是分区（Partition）这些名词概念，在每个消息队列模型中都会涉及一些，含义还不太一样。

### 主题和队列有什么区别
最初的消息队列，就是一个严格意义上的队列。
> *队列是先进先出（FIFO, First-In-First-Out）的线性表（Linear List）。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为 rear）进行插入操作，在前端（称为 front）进行删除操作。*








