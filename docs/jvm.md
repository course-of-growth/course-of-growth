## 一.Java代码是如何运行的
### 为什么Java要在虚拟机中运行
参考：[
jvmbytes](http://jvmbytes.com/#/learning-java/jvm/java-jvm-arch)
- Java作为有一门高级语言，其语法比较复杂，抽象度高，所以直接运行在硬件上并不现实，通过设计一个面向Java语言的虚拟机，通过编译器Java程序转换成字节码，生成的字节码从文件可以运行在各种平台上，这也就体现了Java跨平台的特性。
- 虚拟机的另一个好的出就是托管环境，Java虚拟机能够自动进行内存管理和垃圾回收。
- Java虚拟机还提供了注入数组索引越界、动态类型、安全权限等动态监测，开发者只需将重点放在业务开发。

### Java字节码是怎么运行的
以HotSpot虚拟机为例：
- 首先虚拟机将编译生成的字节码文件加载，存放于方法区（Method Area）,在实际运行过程中，虚拟机会执行方法区中的代码。
- Java虚拟机会将栈细分为面向Java 方法的Java 方法栈，面向本地方法的本地方法栈，以及存放各个线程执行位置的PC寄存器。
- 在运行过程中，每当调用一个Java方法，Java虚拟机就会在当前线程的Java方法栈中生成一个栈帧，用来存放局部变量以及字节码的操作数。每个栈帧的大小是提前计算好的，而且Java虚拟机不要求栈帧在内存中连续分布。
- 在退出当前执行的方法时，不论此方法是正常返回还是发生异常，Java虚拟机都会弹出当前线程的当前栈帧，并将之舍弃。

### Java是一种编译型语言还是解释型语言？

参考：[知乎：Java 是编译型语言还是解释型语言？](https://www.zhihu.com/question/19608553)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200527002646554.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RhbGxpbkM=,size_16,color_FFFFFF,t_70)

从硬件角度来看，Java字节码文件是无法直接运行在机器上的，需要将字节码文件转换为机器码。
在HotSpot里面，将Java字节码文件转换为机器码有两种实现方式：
- 解释执行（interpreter）：逐条将字节码文件翻译成机器码，即将程序计数器中指向的待执行的java字节码翻译为cpu可以运行的机器指令。这种方式的优势就是无需等待编译。
- 即时编译（JIT）：将一个方法中包含的所有字节码编译成机器码然后执行，其优势就是实际运行速度更快。

 HotSpot默认采用混合方式，先解释执行字节码，然后将那些反复出现的热点代码以方法为单位进行即时编译。

### Java虚拟机是如何提高运行效率
HotSpot采用了很多的技术来提升启动性能以及峰值性能，上面所提到的即时编译就是其中一种重要的技术

即时编译建立在程序符合二八定律的假设上，也就是百分之二十的代码占据了百分之八十的计算资源。

**对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，采用解释执行的方式运行；另一方面，对于一小部分的热点代码，则可以将其编译成为机器码，以提高运行速度。**

为满足不同场景，HotSpot内置了多个即时编译器：
- `C1`:又称为Client编译器，主要适用于对启动性能有要求的客户端GUI程序，采用的优化手段相对简单，因此编译时间较短
- `C2`：有称为Servcer编译器，适用于对峰值性能有要求的服务端程序，采用的优化手段较为复杂，因此其编译时间较长，同时生成代码的执行效率较高。
- `Graal`:Java10引入，与interpreter、GC等JVM的其他一些子系统相比较，JIT compiler并不依赖与诸如直接使用内存访问的底层语言特性。可以把它看成是一个输入Java bytecode 输出二进制码的黑盒，其实现方式取决于开发者对开发效率，可维护性的要求。Graal是一个Java作为主要编程语言，面向Java bytecode的编译器。与C++实现的C1与C2相比，它的模块化更加明显，也更加容易维护。Graal既可以作为动态编译器，在运行时编译热点方法；亦可以作为静态编译器，实现AOT编译（ahead of time conpilation）在线下将bytecode 编译成机器码以解决启动性能不好的问题。
参考：[Java10来了，来看看它一同发布的全新JIT编译器
](https://mp.weixin.qq.com/s?__biz=MzIzNjI1ODc2OA==&mid=2650887163&idx=1&sn=12c7182e42659e4c5bcb0b8c61442e3d&chksm=f32f6744c458ee52783af6d315db377acf7587de1cf13f7bf3b76e2dfe7d2fffddad53c5958f&mpshare=1&scene=23&srcid=&sharer_sharetime=1591027260610&sharer_shareid=caee56c3dcf3edfff43d8bc355b0e54d#rd)

之所以有这么多的即时编译器，就是为了在编译时间和生成代码的执行效率之间进行取舍。

从Java7开始，HotSpot默认采用分层编译的方式：即热点方法首先会被C1编译，然后热点方法中热点会进一步被C2编译。

为了不干扰应用的正常运行，HotSpot的即时编译是放在额外的编译线程中进行。HotSpot会根据CPU的数量设置编译线程的数目，并且按照1:2的比例配置给C1及C2编译器。

计算资源充足的情况下，字节码的解释执行和编译执行是可以同时进行的。编译完成的机器码会在下次替换那个该方法的时候启用，替换原来的解释执行。